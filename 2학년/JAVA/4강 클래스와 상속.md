# 4강 클래스와 상속

### static 필드 (정적 필드, 클래스 변수)
클래스의 모든 객체가 공유하는 데이터
- 객체의 생성 없이 항상 사용 가능
- 어떤 객체도 값 변경 가능 (모든 객체가 공유)
- 프로그램 시작 시 초기화

### static 메소드 (정적 메소드, 클래스 메소드)
객체와 무관하게 호출되고 실행됨
- 메소드 내에 this 사용 불가 (특정 객체와 무관하기에 사용 불가)
- static 메소드는 static 필드를 다룸
- ex) Math.sqrt(2); 

### final
불변성을 의미하는 키워드

#### final 필드
상수데이터
- 선언 시 초기 값 지정

#### final 메소드
자식 클래스로 상속은 가능하지만 클래스에서 오버라이딩(재정의) 할 수 없음

## 상속
### 클래스의 재사용
합성
- 기존에 존재하는 클래스를 새로은 클래스 정의에서 데이터 필드 자료형으로 사용
- has-a 관계
- class Line { Point point; } // 이렇게요 !

#### 상속
- 기존 부모 클래스를 사용해서 새로운 자식 클래스를 정의하는 것
- 코드의 중복을 줄이고 확장성 높임
- 기존 클래스의 확장하는 개념
- 자식 is-a 부모의 관계

자식 클래스는 부모 클래스의 필드와 메소드를 상속 받음
- B extends A // 부모 A클래스를 상속 받은 B클래스를 만듦
- 자바는 단일 상속만 가능 // 부모가 2개는 불가. 단 인터페이스는 다중 상속 가능

#### 메소드 오버 라이딩
부모로 상속 받은 메소드 몸체를 자식 클래스에서 재정의 하는 것!
- 부모와 자식에서 같은 이름의 메소드가 다른 기능을 수행한다.

#### this 같은 클래스의 다른 생성자를 호출
메소드 호출 시 숨은 인자로 this가 메소드에 전달됨
- this는 현재 객체에 대한 참조값을 가지고 있음
- static 메소드에 사용 불가

#### supder 자식 클래스의 생성자 몸체에서 부모 클래스 생성자 호출
this와 자료형이 같으나 부모 클래스 //this는 자식 클래스

자식 클래스의 인스턴스 메소드나 생성자에서 사용.

- static 메소드에 사용 불가
- 부모 클래스에서 오버로딩 당한 메소드를 호출하거나 상속되었지만 감춰친 필드에 접근할 때 사용

~~~ java

Class Sub extends Super {
  public double x = 1;

  public void print() {
    System.out.printlin(super.x) // 부모 쪽에 정의 된 변수를 사용할 때 super 사용
  }
}
~~~

### 메소드 체이닝
하나의 명령문에서 동일 객체에 대해 연속적으로 메소드 호출하는 프로그래밍 기법
- 메소드 체이닝의 메소드는 현재 객체의 참조값(this)을 반환

<img width="1686" alt="스크린샷 2024-04-29 오후 12 15 24" src="https://github.com/lliimm318/university/assets/66578746/69ffb5c3-3c76-4a0e-b85a-134405314621">

왼쪽을 코드를 체이닝을 적용하면 오른쪽 코드가 된다.

오른쪽 코드 처럼 setName 함수에 return this를 넣어서 구현.. 하는 방식


